from msilib.schema import _Validation_records
from tkinter import Scale
import numpy as np
import gym

from projects.cda0.simple_highway_with_ramp import SimpleHighwayRamp
from simple_highway_with_ramp import SimpleHighwayRamp

class SimpleHighwayRampWrapper(SimpleHighwayRamp):
    """Wraps the custom environment in order to properly convert observations and actions into usable structures for
        use by a torch NN.
    """

    def __init__(self,
                    config      : gym.EnvContext
                ):

        super().__init__(config)


    def reset(self,
                seed    :   int = None,     #seed value for the PRNG
                options :   object = None   #currently not recognized by the Env, but appears for syntactic compliance
             ) -> np.array:                 #returns a scaled vector of observations usable by a NN

        """Invokes the environment's reset method, then scales the resulting observations to be usable by a NN."""

        obs = super.reset(seed, options)
        return self._scale_obs(obs)


    def step(self,
                action  :   list            #list of actions output from an NN
            ) -> tuple[np.array, list, list, dict]: #returns scaled obs, rewards, dones and infos, where obs are scaled for NN consumption

        """Unscales the input actions from NN compliance to the 'raw' scale expected by the environment, then
            passes these actions to the environment, and scales the resulting observations from an environment step,
            such that it will be usable by a NN.  The rewards, dones and info structures are not modfied.
        """

        a = self._unscale_actions(action)
        raw_obs, r, d, i = super.step(a)
        o = self._scale_obs(raw_obs)

        return o, r, d, i


    ##### internal methods #####

    def _unscale_actions(self,
                            actions : list  #scaled actions generated by a NN
                        ) -> list:          #returns list of unscaled actions usable by the environment

        """Converts a list of action values from scaled, NN compliance to the scale expected by the parent environment."""

        unscaled = [None]*2
        unscaled[0] = actions[0] * SimpleHighwayRamp.MAX_ACCEL  #accel command
        unscaled[1] = actions[1]

        return unscaled


    def _scale_obs(self,
                    obs     : np.array  #raw observation vector from the environment
                  ) -> np.array:        #returns obs vector scaled for use by NN

        """Converts a raw observation vector from the parent environment to a scaled vector usable by a NN."""

        scaled = [None]*SimpleHighwayRamp.OBS_SIZE

        scaled[self.EGO_LANE_ID] = obs[self.EGO_LANE_ID]
        # An NN can't do anything with lane IDs directly.  The best we can tell it (in this version) is that something
        # is happening in the agent's own lane, or in the lane immediately to its left or in the lane immediately to its
        # right.  Therefore, these translations are specific to the roadway geometry hard-coded in this version.

        # EGO_LANE_ID not used - EGO* represents the agent vehicle
        scaled[self.EGO_X]              = obs[self.EGO_X]               / SimpleHighwayRamp.SCENARIO_LENGTH     #range [0, 1]
        scaled[self.EGO_SPEED]          = obs[self.EGO_SPEED]           / SimpleHighwayRamp.MAX_SPEED           #range [0, 1]
        scaled[self.EGO_LANE_REM]       = obs[self.EGO_LANE_REM]        / SimpleHighwayRamp.SCENARIO_LENGTH     #range [0, 1]
        scaled[self.N1_LANE_ID]         = -1 #in lane 1 is one lane to the left of the agent
        scaled[self.N1_X]               = obs[self.N1_X]                / SimpleHighwayRamp.SCENARIO_LENGTH     #range [0, 1]
        scaled[self.N1_SPEED]           = obs[self.N1_SPEED]            / SimpleHighwayRamp.MAX_SPEED           #range [0, 1]
        scaled[self.N1_LANE_REM]        = obs[self.N1_LANE_REM]         / SimpleHighwayRamp.SCENARIO_LENGTH     #range [0, 1]
        scaled[self.N2_LANE_ID]         = -1 #in lane 1 is one lane to the left of the agent
        scaled[self.N2_X]               = obs[self.N1_X]                / SimpleHighwayRamp.SCENARIO_LENGTH     #range [0, 1]
        scaled[self.N2_SPEED]           = obs[self.N1_SPEED]            / SimpleHighwayRamp.MAX_SPEED           #range [0, 1]
        scaled[self.N2_LANE_REM]        = obs[self.N1_LANE_REM]         / SimpleHighwayRamp.SCENARIO_LENGTH     #range [0, 1]
        scaled[self.N3_LANE_ID]         = -1 #in lane 1 is one lane to the left of the agent
        scaled[self.N3_X]               = obs[self.N1_X]                / SimpleHighwayRamp.SCENARIO_LENGTH     #range [0, 1]
        scaled[self.N3_SPEED]           = obs[self.N1_SPEED]            / SimpleHighwayRamp.MAX_SPEED           #range [0, 1]
        scaled[self.N3_LANE_REM]        = obs[self.N1_LANE_REM]         / SimpleHighwayRamp.SCENARIO_LENGTH     #range [0, 1]
        scaled[self.EGO_ACCEL_CMD_CUR]  = obs[self.EGO_ACCEL_CMD_CUR]   / SimpleHighwayRamp.MAX_ACCEL           #range [-1, 1]
        scaled[self.EGO_ACCEL_CMD_PREV1]= obs[self.EGO_ACCEL_CMD_PREV1] / SimpleHighwayRamp.MAX_ACCEL           #range [-1, 1]
        scaled[self.EGO_ACCEL_CMD_PREV2]= obs[self.EGO_ACCEL_CMD_PREV2] / SimpleHighwayRamp.MAX_ACCEL           #range [-1, 1]
        scaled[self.EGO_LANE_CMD_CUR]   = obs[self.EGO_LANE_CMD_CUR] #range [-1, 1]
        scaled[self.STEPS_SINCE_LN_CHG] = obs[self.STEPS_SINCE_LN_CHG]  / SimpleHighwayRamp.MAX_STEPS_SINCE_LC  #range [0, 1]
        # ADJ_LN_LEFT_ID not used - we will always use -1 to refer to the agent's left lane, and +1 to represent its right lane
        scaled[self.ADJ_LN_LEFT_CONN_A] = obs[self.ADJ_LN_LEFT_CONN_A]  / SimpleHighwayRamp.SCENARIO_LENGTH     #range [0, 1]
        scaled[self.ADJ_LN_LEFT_CONN_B] = obs[self.ADJ_LN_LEFT_CONN_B]  / SimpleHighwayRamp.SCENARIO_LENGTH     #range [0, 1]
        scaled[self.ADJ_LN_LEFT_REM]    = obs[self.ADJ_LN_LEFT_REM]     / SimpleHighwayRamp.SCENARIO_LENGTH     #range [0, 1]
        # ADJ_LN_RIGHT_ID not used - we will always use -1 to refer to the agent's left lane, and +1 to represent its right lane
        scaled[self.ADJ_LN_RIGHT_CONN_A]= obs[self.ADJ_LN_RIGHT_CONN_A] / SimpleHighwayRamp.SCENARIO_LENGTH     #range [0, 1]
        scaled[self.ADJ_LN_RIGHT_CONN_B]= obs[self.ADJ_LN_RIGHT_CONN_B] / SimpleHighwayRamp.SCENARIO_LENGTH     #range [0, 1]
        scaled[self.ADJ_LN_RIGHT_REM]   = obs[self.ADJ_LN_RIGHT_REM]    / SimpleHighwayRamp.SCENARIO_LENGTH     #range [0, 1]

        # Remove any unused list elements
        for i in range(SimpleHighwayRamp.OBS_SIZE - 1, -1, -1):
            if scaled[i] is None:
                scaled.remove(i)
                print("Removed scaled[{}]".format(i))
        print("Final length of scaled = {}".format(len(scaled)))


        # Return the obs as an ndarray
        vec = np.array([scaled])
        print("_scale_obs returning ", vec, ", size = ", vec.shape)

        return vec
